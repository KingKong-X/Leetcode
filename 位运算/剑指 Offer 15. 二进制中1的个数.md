# 剑指 Offer 15. 二进制中1的个数

### 题目描述：

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

### 方法一：逐位判断

n>>=1代表右移一位，相当于/2

n<<=1代表左移一位，相当于*2

如n=11000时，n>>=1就变成1100，n<<=1就变成110000

时间复杂度O(log2n)

空间复杂度O(1)

#### C++代码：

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt=0;
        while(n)
        {
            if(n&1)
            {
                cnt++;
            }
            n>>=1;
        }
        return cnt;
    }
};
```

### 方法二：位运算

当n=25时，二进制是1 1001

当n=24时，二进制是1 1000

n和n-1的关系是：n-1的最右边的1变成0，此1右边的0变成1

因此可以用n&(n-1)，这样n中最右边的1变成0，其余不变

如图所示：

![image-20200818174026593](C:\Users\42303\AppData\Roaming\Typora\typora-user-images\image-20200818174026593.png)

只要n!=0，那么cnt就可以一直+1

#### C++代码：

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt=0;
        while(n)
        {
            cnt++;
            n=n&(n-1);
        }
        return cnt;
    }
};
```

时间复杂度：O(M)   M是1的个数

空间复杂度：O(1)